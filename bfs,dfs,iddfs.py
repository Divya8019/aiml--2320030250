# -*- coding: utf-8 -*-
"""bfs,dfs,iddfs

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cxpGp-N7pAp8oWpZn8TtFsFda7kSXZmB
"""





from collections import deque

def bfs(graph, start):
    visited = set()
    queue = deque([start])
    visited.add(start)

    while queue:
        node = queue.popleft()
        print(node)  # Process the node (e.g., print it)

        for neighbor in graph[node]:
            if neighbor not in visited:
                visited.add(neighbor)
                queue.append(neighbor)

# Example usage:
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}

bfs(graph, 'A')

def dfs_recursive(graph, node, visited=None):
    if visited is None:
        visited = set()

    # Mark the node as visited
    visited.add(node)
    print(node)  # Process the node (e.g., print it)

    # Visit all the adjacent nodes
    for neighbor in graph[node]:
        if neighbor not in visited:
            dfs_recursive(graph, neighbor, visited)

    return visited

# Example usage:
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}

dfs_recursive(graph, 'A')

def dfs_limited(graph, node, target, depth, visited=None):
    if visited is None:
        visited = set()

    if depth < 0:
        return False

    visited.add(node)

    if node == target:
        return True

    for neighbor in graph[node]:
        if neighbor not in visited:
            if dfs_limited(graph, neighbor, target, depth - 1, visited):
                return True

    return False

def iddfs(graph, start, target, max_depth):
    for depth in range(max_depth + 1):
        visited = set()
        if dfs_limited(graph, start, target, depth, visited):
            return True
    return False

# Example usage:
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}

start_node = 'A'
target_node = 'F'
max_depth = 3

found = iddfs(graph, start_node, target_node, max_depth)
print(f"Node {target_node} found: {found}")

import heapq

def best_first_search(graph, start, goal, heuristic):
    # Priority queue to store (cost, node) tuples
    open_set = []
    heapq.heappush(open_set, (heuristic[start], start))

    # Dictionary to store the best path to each node
    came_from = {}
    came_from[start] = None

    while open_set:
        # Get the node with the lowest heuristic cost
        _, current = heapq.heappop(open_set)

        # Check if we've reached the goal
        if current == goal:
            return reconstruct_path(came_from, current)

        # Explore neighbors
        for neighbor in graph.get(current, []):
            if neighbor not in came_from:
                # Add the neighbor to the open set with its heuristic cost
                heapq.heappush(open_set, (heuristic[neighbor], neighbor))
                came_from[neighbor] = current

    return None  # If no path is found

def reconstruct_path(came_from, current):
    path = []
    while current is not None:
        path.append(current)
        current = came_from[current]
    return path[::-1]  # Return reversed path

# Example usage:
graph = {
    'A': ['B', 'C'],
    'B': ['A', 'D', 'E'],
    'C': ['A', 'F'],
    'D': ['B'],
    'E': ['B', 'F'],
    'F': ['C', 'E']
}

# Example heuristic function (straight-line distance or other domain-specific estimate)
heuristic = {
    'A': 6,  # Example values
    'B': 5,
    'C': 2,
    'D': 7,
    'E': 1,
    'F': 0
}

start_node = 'A'
goal_node = 'F'

path = best_first_search(graph, start_node, goal_node, heuristic)
print(f"Path found: {path}")

import heapq

def uniform_cost_search(graph, start, goal):
    # Priority queue to store (cost, node) tuples
    open_set = [(0, start)]

    # Dictionary to store the cost to reach each node
    cost_so_far = {start: 0}

    # Dictionary to store the best path to each node
    came_from = {start: None}

    while open_set:
        # Get the node with the lowest cumulative cost
        current_cost, current = heapq.heappop(open_set)

        # Check if we've reached the goal
        if current == goal:
            return reconstruct_path(came_from, current)

        # Explore neighbors
        for neighbor, edge_cost in graph.get(current, []):
            new_cost = current_cost + edge_cost
            if neighbor not in cost_so_far or new_cost < cost_so_far[neighbor]:
                # Update the cost to reach the neighbor
                cost_so_far[neighbor] = new_cost
                # Add the neighbor to the open set with its total cost
                heapq.heappush(open_set, (new_cost, neighbor))
                # Update the path to the neighbor
                came_from[neighbor] = current

    return None  # If no path is found

def reconstruct_path(came_from, current):
    path = []
    while current is not None:
        path.append(current)
        current = came_from[current]
    return path[::-1]  # Return reversed path

# Example usage:
graph = {
    'A': [('B', 1), ('C', 4)],
    'B': [('A', 1), ('C', 2), ('D', 5)],
    'C': [('A', 4), ('B', 2), ('D', 1)],
    'D': [('B', 5), ('C', 1)]
}

start_node = 'A'
goal_node = 'D'

path = uniform_cost_search(graph, start_node, goal_node)
print(f"Path found: {path}")

import heapq

def a_star_search(graph, start, goal, heuristic):
    # Priority queue to store (total cost, node)
    open_set = []
    heapq.heappush(open_set, (0 + heuristic[start], start))

    # Cost from start to each node
    g_score = {start: 0}

    # Dictionary to store the best path to each node
    came_from = {start: None}

    while open_set:
        # Get the node with the lowest total estimated cost
        current_cost, current = heapq.heappop(open_set)

        # Check if we've reached the goal
        if current == goal:
            return reconstruct_path(came_from, current)

        # Explore neighbors
        for neighbor, edge_cost in graph.get(current, []):
            tentative_g_score = g_score[current] + edge_cost

            if neighbor not in g_score or tentative_g_score < g_score[neighbor]:
                g_score[neighbor] = tentative_g_score
                total_cost = tentative_g_score + heuristic[neighbor]
                heapq.heappush(open_set, (total_cost, neighbor))
                came_from[neighbor] = current

    return None  # If no path is found

def reconstruct_path(came_from, current):
    path = []
    while current is not None:
        path.append(current)
        current = came_from[current]
    return path[::-1]  # Return reversed path

# Example usage:
graph = {
    'A': [('B', 1), ('C', 4)],
    'B': [('A', 1), ('C', 2), ('D', 5)],
    'C': [('A', 4), ('B', 2), ('D', 1)],
    'D': [('B', 5), ('C', 1)]
}

# Example heuristic function (straight-line distance or other domain-specific estimate)
heuristic = {
    'A': 7,  # Example values
    'B': 6,
    'C': 2,
    'D': 0
}

start_node = 'A'
goal_node = 'D'

path = a_star_search(graph, start_node, goal_node, heuristic)
print(f"Path found: {path}")

import math

# Utility function to evaluate the board
def evaluate(board):
    # Example evaluation function for Tic-Tac-Toe
    winning_combinations = [
        [board[0], board[1], board[2]],  # Row 1
        [board[3], board[4], board[5]],  # Row 2
        [board[6], board[7], board[8]],  # Row 3
        [board[0], board[3], board[6]],  # Column 1
        [board[1], board[4], board[7]],  # Column 2
        [board[2], board[5], board[8]],  # Column 3
        [board[0], board[4], board[8]],  # Diagonal 1
        [board[2], board[4], board[6]]   # Diagonal 2
    ]

    # Check for a win for 'X'
    for combo in winning_combinations:
        if combo == ['X', 'X', 'X']:
            return 10
        elif combo == ['O', 'O', 'O']:
            return -10

    # No winner yet
    return 0

def min_max(board, depth, is_max):
    score = evaluate(board)

    # If maximizer has won
    if score == 10:
        return score - depth

    # If minimizer has won
    if score == -10:
        return score + depth

    # If the board is full, it's a tie
    if not any(cell == ' ' for cell in board):
        return 0

    if is_max:
        best = -math.inf
        for i in range(9):
            if board[i] == ' ':
                board[i] = 'X'
                best = max(best, min_max(board, depth + 1, not is_max))
                board[i] = ' '
        return best
    else:
        best = math.inf
        for i in range(9):
            if board[i] == ' ':
                board[i] = 'O'
                best = min(best, min_max(board, depth + 1, not is_max))
                board[i] = ' '
        return best

def find_best_move(board):
    best_val = -math.inf
    best_move = -1

    for i in range(9):
        if board[i] == ' ':
            board[i] = 'X'
            move_val = min_max(board, 0, False)
            board[i] = ' '

            if move_val > best_val:
                best_move = i
                best_val = move_val

    return best_move

# Example usage
board = ['X', 'O', 'X',
         ' ', 'X', ' ',
         'O', ' ', 'O']

best_move = find_best_move(board)
print(f"The best move is at position {best_move}")

import math

def evaluate(board):
    # Example evaluation function for Tic-Tac-Toe
    winning_combinations = [
        [board[0], board[1], board[2]],  # Row 1
        [board[3], board[4], board[5]],  # Row 2
        [board[6], board[7], board[8]],  # Row 3
        [board[0], board[3], board[6]],  # Column 1
        [board[1], board[4], board[7]],  # Column 2
        [board[2], board[5], board[8]],  # Column 3
        [board[0], board[4], board[8]],  # Diagonal 1
        [board[2], board[4], board[6]]   # Diagonal 2
    ]

    # Check for a win for 'X'
    for combo in winning_combinations:
        if combo == ['X', 'X', 'X']:
            return 10
        elif combo == ['O', 'O', 'O']:
            return -10

    # No winner yet
    return 0

def alpha_beta(board, depth, alpha, beta, is_max):
    score = evaluate(board)

    # If maximizer has won
    if score == 10:
        return score - depth

    # If minimizer has won
    if score == -10:
        return score + depth

    # If the board is full, it's a tie
    if not any(cell == ' ' for cell in board):
        return 0

    if is_max:
        best = -math.inf
        for i in range(9):
            if board[i] == ' ':
                board[i] = 'X'
                best = max(best, alpha_beta(board, depth + 1, alpha, beta, not is_max))
                board[i] = ' '
                alpha = max(alpha, best)
                if beta <= alpha:
                    break  # Beta cut-off
        return best
    else:
        best = math.inf
        for i in range(9):
            if board[i] == ' ':
                board[i] = 'O'
                best = min(best, alpha_beta(board, depth + 1, alpha, beta, not is_max))
                board[i] = ' '
                beta = min(beta, best)
                if beta <= alpha:
                    break  # Alpha cut-off
        return best

def find_best_move(board):
    best_val = -math.inf
    best_move = -1
    alpha = -math.inf
    beta = math.inf

    for i in range(9):
        if board[i] == ' ':
            board[i] = 'X'
            move_val = alpha_beta(board, 0, alpha, beta, False)
            board[i] = ' '

            if move_val > best_val:
                best_move = i
                best_val = move_val

    return best_move

# Example usage
board = ['X', 'O', 'X',
         ' ', 'X', ' ',
         'O', ' ', 'O']

best_move = find_best_move(board)
print(f"The best move is at position {best_move}")