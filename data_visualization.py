# -*- coding: utf-8 -*-
"""data visualization

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Wg9z1Qj5cwF6Uq855bhx9niZgiDYL5CQ
"""



from collections import deque

def bfs(g, s):
    q = deque([s])
    v = set()
    v.add(s)
    while q:
        n = q.popleft()
        print(n, end=" ")
        for i in g[n]:
            if i not in v:
                v.add(i)
                q.append(i)

# Correct graph definition
g = {
    'A': ['B', 'C'],
    'B': ['D', 'E'],
    'C': ['F'],
    'D': [],
    'E': [],
    'F': []
}
bfs(g, 'A')

class Graph:
    def __init__(self):
        self.graph = {}

    def add_edge(self, u, v):
        if u not in self.graph:
            self.graph[u] = []
        if v not in self.graph:
            self.graph[v] = []
        self.graph[u].append(v)
        self.graph[v].append(u)

    def iddfs(self, start, goal):
        depth = 0
        while True:
            print(f"Searching with depth limit {depth}")
            found = self.dls(start, goal, depth)
            if found:
                print(f"Goal {goal} found!")
                return
            depth += 1

    def dls(self, node, goal, depth):
        if depth == 0:
            return node == goal
        elif depth > 0:
          if node in self.graph:
                for neighbor in self.graph[node]:
                    if self.dls(neighbor, goal, depth - 1):
                        return True
        return False

if __name__ == "__main__":
    g = Graph()
    g.add_edge('A', 'B')
    g.add_edge('A', 'C')
    g.add_edge('B', 'D')
    g.add_edge('B', 'E')
    g.add_edge('C', 'F')
    g.add_edge('D', 'G')

    g.iddfs('A', 'D')

from collections import deque, defaultdict

class Graph:
    def __init__(self):
        self.__graph = defaultdict(list)  # Private attribute to store the graph

    def add_edge(self, u, v):
        self.__graph[u].append(v)

    def bfs(self, start_vertex):
        visited = set()
        queue = deque([start_vertex])
        visited.add(start_vertex)

        while queue:
            vertex = queue.popleft()
            print(vertex, end=" ")

            for neighbor in self.__graph[vertex]:
                if neighbor not in visited:
                    queue.append(neighbor)
                    visited.add(neighbor)

    def __str__(self):
        return str(dict(self.__graph))
        # Example usage
if __name__ == "__main__":
    g = Graph()
    g.add_edge(0, 1)
    g.add_edge(0, 2)
    g.add_edge(1, 2)
    g.add_edge(2, 0)
    g.add_edge(2, 3)
    g.add_edge(3, 3)

    print("Following is Breadth First Traversal (starting from vertex 2):")
    g.bfs(2)

from collections import deque

class Graph:
    def __init__(self):
        # Dictionary to store the graph as an adjacency list
        self.graph = {}

    def add_edge(self, u, v):
        """Add an edge from node u to node v."""
        if u not in self.graph:
            self.graph[u] = []
        if v not in self.graph:
            self.graph[v] = []
            self.graph[u].append(v)
        self.graph[v].append(u)  # For undirected graph

    def bfs(self, start):
        """Perform Breadth-First Search (BFS) from a given start node."""
        if start not in self.graph:
            print("Start node not in the graph")
            return

        # Initialize the queue and visited set
        queue = deque([start])
        visited = set()
        visited.add(start)
        result = []

        while queue:
            node = queue.popleft()
            result.append(node)
            for neighbor in self.graph[node]:
                if neighbor not in visited:
                    visited.add(neighbor)
                    queue.append(neighbor)

        print("BFS Traversal:", " ".join(result))
        # Example usage
if __name__ == "__main__":
    g = Graph()
    g.add_edge('A', 'B')
    g.add_edge('A', 'C')
    g.add_edge('B', 'D')
    g.add_edge('B', 'E')
    g.add_edge('C', 'F')

    g.bfs('A')

from matplotlib import pyplot as plt

 #Plotting to our canvas

plt.plot([1,2,3],[4,5,1])

 #Showing what we plotted

plt.show()

x = [5,2,7]
y = [2,16,4]
plt.plot(x,y)
plt.title('Info')
plt.ylabel('Y axis')
plt.xlabel('X axis')
plt.show()

from matplotlib import pyplot as plt
from matplotlib import style

style.use('ggplot')
x = [5,8,10]
y = [12,16,6]
x2 = [6,9,11]
y2 = [6,15,7]
plt.plot(x,y,'g',label='line one', linewidth=5)
plt.plot(x2,y2,'c',label='line two',linewidth=5)
plt.title('Epic Info')
plt.ylabel('Y axis')
plt.xlabel('X axis')
plt.legend()
plt.grid(True,color='k')
plt.show()

from matplotlib import pyplot as plt

plt.bar([0.25,1.25,2.25,3.25,4.25],[50,40,70,80,20],
label="BMW",color='g',width=.5)
plt.bar([.75,1.75,2.75,3.75,4.75],[80,20,20,50,60],
label="Audi", color='r',width=.5)
plt.legend()
plt.xlabel('Days')
plt.ylabel('Distance (kms)')
plt.title('Information')
plt.show()

import matplotlib.pyplot as plt
population_age = [22,55,62,45,21,22,34,42,42,4,2,102,95,85,55,110,120,70,65,55,111,115,80,75,65,54,44,43,42,48]
bins = [0,10,20,30,40,50,60,70,80,90,100]
plt.hist(population_age, bins, histtype='bar', rwidth=0.8)
plt.xlabel('age groups')
plt.ylabel('Number of people')
plt.title('Histogram')
plt.show()

import matplotlib.pyplot as plt
x = [1,1.5,2,2.5,3,3.5,3.6]
y = [7.5,8,8.5,9,9.5,10,10.5]

x1=[8,8.5,9,9.5,10,10.5,11]
y1=[3,3.5,3.7,4,4.5,5,5.2]

plt.scatter(x,y, label='high income low saving',color='r')
plt.scatter(x1,y1,label='low income high savings',color='b')
plt.xlabel('saving*100')
plt.ylabel('income*1000')
plt.title('Scatter Plot')
plt.legend()
plt.show()

import matplotlib.pyplot as plt

days = [1,2,3,4,5]

sleeping =[7,8,6,11,7]
eating = [2,3,4,3,2]
working =[7,8,7,2,2]
playing = [8,5,7,8,13]
slices = [7,2,2,13]
activities = ['sleeping','eating','working','playing']
cols = ['c','m','r','b']

plt.pie(slices,
  labels=activities,
  colors=cols,
  startangle=90,
  shadow= True,
  explode=(0,0.1,0,0),
  autopct='%1.1f%%')

plt.title('Pie Plot')
plt.show()

import numpy as np
import matplotlib.pyplot as plt

def f(t):
    return np.exp(-t) * np.cos(2*np.pi*t)
t1 = np.arange(0.0, 5.0, 0.1)
t2 = np.arange(0.0, 5.0, 0.02)
plt.subplot(221)
plt.plot(t1, f(t1), 'bo', t2, f(t2))
plt.subplot(222)
plt.plot(t2, np.cos(2*np.pi*t2))
plt.show()

import seaborn as sns
import matplotlib.pyplot as plt

# Load the 'tips' dataset
tips = sns.load_dataset('tips')

# Plot results of aggregation
tips.groupby('smoker')['total_bill'].mean().plot(kind='bar')
plt.show()

#using additional arguments
tips['total_bill'].plot(kind = 'density', title = 'A Density Plot')

#same as using pyplot directly
plt.hist(tips['total_bill'])

#plot a single quantitative feature
tips['total_bill'].plot()

import seaborn as sns
import matplotlib.pyplot as plt

df = sns.load_dataset('iris')
df.head()

sns.boxplot( y=df["sepal_length"] );

x = np.random.random(1000)
y = np.random.random(1000)
plt.scatter(x, y)





import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

diabetes_data=pd.read_csv('diabetes.csv')
diabetes_data.head()

diabetes_data=pd.read_csv('diabetes.csv')
diabetes_data.tail()

diabetes_data=pd.read_csv('diabetes.csv')
diabetes_data.info()

diabetes_data=pd.read_csv('diabetes.csv')
diabetes_data.head()

diabetes_data.info()